<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//DE">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Unix/Linux benutzen 2</TITLE>
<META NAME="description" CONTENT="Unix/Linux benutzen 2">
<META NAME="keywords" CONTENT="Uebungen">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="Uebungen.css">
<LINK REL="next" HREF="node11.html">
<LINK REL="previous" HREF="node9.html">
<LINK REL="up" HREF="Uebungen.html">
<LINK REL="next" HREF="node11.html">
</HEAD>
<BODY >

<H1><A NAME="SECTION00080000000000000000">
Unix/Linux benutzen 2</A>
</H1>

<P>
<DL COMPACT>
<DT>1.
<DD>Setze die Variable <TT>MONTY</TT> auf den Wert <TT>python</TT>. Versichere
dich, daß du das richtig gemacht hast.
<DT>2.
<DD>Starte nun eine Subshell (durch Eingabe von <TT>bash</TT>.
<DT>3.
<DD>Gib die Variable aus. Welchen Wert hat sie?
<DT>4.
<DD>Verlasse die Shell durch <TT>exit</TT>. Sieh dir erneut den Wert der Variablen an!
<DT>5.
<DD>Lösche die Variable. 
<DT>6.
<DD>Setze sie nun mittels <TT>export</TT> und öffne wieder eine Subshell. Kannst du das
erwartete Ergebnis bestätigen? Verlasse die Subshell und lösche die Variable.
<DT>7.
<DD>Sieh dir nun an, welche Variablen vom System zum jetzigen Zeitpunkt gesetzt sind.
<DT>8.
<DD>Verwende einige dieser Variablen in Kombination mit Befehlen, um z.B. in dein
Homeverzeichnis zu wechseln oder deinen Kommandoprompt (<TT>PS1</TT>) zu ändern.
<DT>9.
<DD>Setze die Var. <TT>HOME</TT> auf <TT>/</TT>. Gib <TT>cd</TT> ein. Was fällt dir auf?
Setze nun <TT>HOME</TT> wieder auf den korrekten Wert (<TT>/home/$USER</TT>).
<DT>10.
<DD>Schreibe die Version der laufenden Bash in die Datei <TT>bash-ver</TT>.
<DT>11.
<DD>Gehe nach <TT>/usr/include</TT>. Leite das Listing aller Dateien <TT>k*.h</TT> in 
die Variable <TT>MYLS</TT> um (Hinweis: Das richtige Anführungszeichen ist das neben 
der Rücktaste, bei gedrücktem <TT>Shift</TT>). Schau dir an, ob das korrekt erfolgt ist.
<DT>12.
<DD>Schreibe nun eine Schleife, die dir jeweils den Namen der aktuellen Datei in 
<TT>MYLS</TT> und nach Bestätigen der Return-Taste (verwende dafür <TT>read</TT>) die Datei 
selbst am Bildschirm ausgibt. Wirst du eine <TT>for</TT>- oder <TT>while</TT>-Schleife 
verwenden?
<DT>13.
<DD>Versuche, mit einer Schleife herauszufinden, wie viele Dateien die Variable
<TT>MYLS</TT> enthält. Welcher Typ von Schleife ist hier besser geeignet? (Wechsle danach
wieder in dein Homeverzeichnis!).
<DT>14.
<DD><EM>Extraaufgabe</EM>: Schreibe eine Schleife, die mehrere Dateien zugleich von *.txt
nach *.text umbenennt (<TT>man basename</TT>). Erzeuge dafür vorher einige .txt Dateien.
<DT>15.
<DD><EM>Für Profis</EM>: Mach ein Script namens <TT>mmv</TT> daraus, das in etwa wie folgt
funktioniert: <TT>mmv *.htm *.html</TT> (Hinweis: das erste Argument, das dem Befehl
mitgegeben wird, erhält man in der speziellen Variable <TT>$1</TT>, das zweite in
<TT>$2</TT>.
<BR>
<DT>16.
<DD>Sieh dir die fünf Dateien an, die beim Ein- bzw. Ausloggen ausgeführt werden.
Versuche nachzuvollziehen, was sie machen.
<DT>17.
<DD>Konfiguriere deine <TT>.bash_profile</TT>. Setze z.B. einen Prompt (Variable 
<TT>PS1</TT>, Erklärung in <TT>man bash</TT>, Section <TT>PROMPTING</TT>), gib eine
Begrüßung aus oder laß dir anzeigen, wer gerade eingeloggt ist.
<DT>18.
<DD>Finde heraus, in welcher der Dateien Aliase gesetzt werden sollen (und auf die
du Schreibrechte hast!) und füge einige hinzu, die du für nützlich hälst.
<DT>19.
<DD>Beende die <TT>konsole</TT> und starte sie erneut, damit du überprüfen kannst, 
ob deine Änderungen erfolgreich waren.
<BR>
<DT>20.
<DD>Laß dir eine einfache Liste der laufenden Prozesse ausgeben.
<DT>21.
<DD>Versuche, deine bash mit PID oder Name zu killen. Gelingt dir das? 
Verwende auch verschiedene Signale!
<DT>22.
<DD>Laß dir eine lange Liste aller laufenden Prozesse ausgeben. Versuche einen
Prozeß zu killen, der nicht dir gehört. Darfst du das?
<DT>23.
<DD>Untersuche eine beliebige Zeile des langen Listings, welche Informationen sie
bietet.
<DT>24.
<DD>Starte <TT>top</TT>. Welche Informationen bietet es? Finde heraus, was und wie hoch 
die Load average ist (warum gibt es drei Werte dafür?) Finde heraus, wieviel
Hauptspeicher derzeit benutzt wird und wieviel noch frei ist. Sortiere das Prozeßlisting
nach Speicherverbrauch. Sieh dir auch die anderen Optionen an und beende dann <TT>top</TT>
wieder.
<DT>25.
<DD>Starte im Hintergrund das Programm <TT>xeyes</TT>. Laß dir alle deine 
Hintergrund-Prozesse anzeigen und versuche das Programm in den Vordergrund und dann 
wieder in den Hintergrund zu setzen. Beende es schließlich.
<DT>26.
<DD>Gehe nach <TT>/usr</TT>. Schreibe ein rekursives <TT>ls</TT> so in eine Datei, daß
du inzwischen diese Shell beenden kannst. Öffne eine neue Shell. Ist die Datei da?
Wurde alles hineingeschrieben?
<DT>27.
<DD>Versuche herauszufinden, welche Dämonen am Server laufen und was diese tun.
Schaue notfalls in einer Manpage nach.
<BR>
<P>
<DT>28.
<DD>Erstelle ein komprimiertes Backup deiner bisherigen Übungsdateien in die Datei
<TT>meine-ueb.tar.gz</TT>. Kann man bei <TT>tar</TT> mehrere Dateien, die ins Archiv sollen,
gleichzeitig angeben?
<DT>29.
<DD>Mach ein neues Verzeichnis <TT>auspack</TT> und bewege das <TT>tar.gz</TT>-File dorthin.
<DT>30.
<DD>Entpacke es dort. Hat es alle Dateien enthalten? Werden alle Dateien 
wiederhergestellt?
<DT>31.
<DD>Kopiere <TT>/home/praxis/test/linux-history</TT> in dein Homeverzeichnis. Notiere 
die Größe dieser Datei. Komprimiere sie. Vergleiche die resultierende Größe.
<DT>32.
<DD>Komprimiere die (wieder dekompr.) Datei mit bzip2. Wie groß ist die Datei im
Vergleich zur unkompr. und zur <TT>gzip</TT>-kompr.? Komprimiert <TT>gzip</TT> oder 
<TT>bzip2</TT> besser?
<BR>

<P>
<DT>33.
<DD>Analysiere <TT>/etc/passwd</TT> und laß dir die Benutzer und das jeweils zugehörige
Homedirectory ausgeben. Probiere zuerst, wie man <TT>cut</TT> mehrere Spalten gleichzeitig
übergibt.
<DT>34.
<DD>Erreiche mit einer Verknüpfung mit <TT>grep</TT>, daß nur User ausgegeben werden, 
die ihr Homeverzeichnis in <TT>/home</TT> haben.
<DT>35.
<DD>Versuche, ein Listing der <TT>/etc/passwd</TT> zu bekommen, das alle User außer
<TT>root</TT> und Zeilennummern enthält. Schreibe es in die Datei <TT>passwd-no-root</TT>!
<DT>36.
<DD>Sortiere die Zeilen in <TT>/etc/services</TT>, filtere Kommentare heraus (welches
Problem stellt sich dabei? Schau auf der Manpage von <TT>grep</TT> unter Regular 
Expressions nach, was <TT>^ </TT> bedeutet) und schreibe, wenn du mit der Sortierung zufrieden bist, das Ergebnis in <TT>sorted-services</TT>.
<DT>37.
<DD>Informiere dich über die grundlegende Funktionsweise von <TT>sed</TT> und <TT>awk</TT>.
<BR>
<DT>38.
<DD>Schau die Datei <TT>/home/praxis/test/linux-history</TT> einmal mit <TT>head</TT> und
einmal mit <TT>tail</TT> an. Zeige jeweils 22 Zeilen der Datei an und schreibe das Ergebnis
nach <TT>hist.head</TT> resp. <TT>hist.tail</TT>.
<BR>
<DT>39.
<DD>Finde heraus, wo im Pfad sich die Befehle <TT>cp</TT>, <TT>xeyes</TT> und <TT>konsole</TT>
befinden.
<DT>40.
<DD>Um welche Dateitypen handelt es sich dabei? Welchen Dateityp haben 
<TT>/usr/share/sounds/info.wav</TT> und <TT>/etc/init.d/sshd</TT>?
<BR>
<DT>41.
<DD>Gehe nach <TT>/usr/lib</TT>. Suche alle Dateien, die auf <TT>.so</TT> enden. Um welche
Dateitypen handelt es sich dabei?
<DT>42.
<DD>Wieder im Homeverzeichnis zurück, schreibe ein <TT>find</TT> Kommando, das dir die
vorher erstellten *.text Dateien (nach Bestätigung!) löscht.
<DT>43.
<DD>Untersuche auf dem schnellsten Weg das Dateisystem nach dem Dateimuster 
<TT>ssh</TT>. Kannst du die gefundenen Dateien schon ihrer Funktion zuordnen?
<BR>
<DT>44.
<DD><EM>Zum Abschluß für Profis</EM>: Schreibe ein kleines Dictionary, das Abkürzungen 
den vollständig ausgeschriebenen (einzeiligen) Begriffen zuordnet, indem du die dir 
bekannten Tools kombinierst. Es sollte möglich sein, Datensätze hinzuzufügen, zu 
entfernen oder anzusehen. Aufgebaut ist 
alles rund um eine zentrale Datenbank, die aus einer Textdatei besteht, deren Format
durch 1. Spalte: Abkürzung, 2. Spalte: Tabulator, 3. Spalte: ausgeschriebener Text
definiert ist. <BR>
Hinweise: Entweder schreibst du für jede Funktion ein eigenes Script oder du
machst ein Menü (<TT>help select</TT>). Mit <TT>read VAR</TT> werden Variablen von der
Standardeingabe gelesen. Auch der Befehl <TT>test</TT> dürfte recht nützlich sein. Ein
Tabulator wird durch 
<!-- MATH: $\backslash$ -->
2#2<TT>t</TT> dargestellt.
</DL>
<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html130"
 HREF="node11.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html127"
 HREF="Uebungen.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html121"
 HREF="node9.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html129"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html131"
 HREF="node11.html">&Uuml;ber dieses Dokument ...</A>
<B> Up:</B> <A NAME="tex2html128"
 HREF="Uebungen.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html122"
 HREF="node9.html">Editoren</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Martin Piskernig</I>
<BR><I>2000-11-10</I>
</ADDRESS>
</BODY>
</HTML>
